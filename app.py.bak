from flask import Flask, request, redirect, render_template, url_for
from werkzeug.security import generate_password_hash, check_password_hash
from models import db, User
import uuid
import click
from flask.cli import with_appcontext
import os

# Импорты flask-login
from flask_login import LoginManager, login_user, logout_user, login_required, current_user

app = Flask(__name__)
app.secret_key = 'your_secret_key_here'  # Замените на сильный секретный ключ
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db.init_app(app)

# Настройка Flask-Login
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'  # куда редиректить неавторизованных

# Функция загрузки пользователя по UUID
@login_manager.user_loader
def load_user(user_uuid):
    return User.query.filter_by(uuid=user_uuid).first()


@app.route('/')
def index():
    if current_user.is_authenticated:
        return render_template('index_authorized.html', user=current_user, active_page="index")
    else:
        return render_template('index_unauthorized.html')

@app.route('/settings', methods=['GET', 'POST'])
@login_required
def update_settings():
    if request.method == 'POST':
        form = request.form
        nickname = form.get('nickname')
        first_name = form.get('first_name')
        last_name = form.get('last_name')
        email = form.get('email')
        telegram = form.get('telegram')
        password = form.get('password')
        description = form.get('description')

        # Валидация обязательных полей
        if not nickname or not telegram or not password:
            return render_template("settings.html", user=current_user, message="Пожалуйста, заполните обязательные поля", active_page="settings")

        # Обновление полей
        current_user.nickname = nickname
        current_user.first_name = first_name
        current_user.last_name = last_name
        current_user.email = email
        current_user.telegram = telegram
        current_user.profile_description = description

        # Сохраняем хеш пароля (или обычный текст, если ты точно решил так)
        current_user.password = generate_password_hash(password)  # ⚠️ Или просто `= password` (если нет хеширования)

        db.session.commit()
        return render_template("settings.html", user=current_user, message="Профиль обновлён успешно", active_page="settings")

    return render_template("settings.html", user=current_user, active_page="settings")

@app.route('/rating', methods=['GET'])
@login_required
def rating():
    users = User.query.order_by(User.score.desc()).all()
    return render_template('rating.html', users=users, active_page="rating")


@app.route('/servers', methods=['GET', 'POST'])
@login_required
def servers():
    if request.method == 'GET':
        return render_template('machines.html')
    return None


@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        data = request.form
        used_invite = data.get('used_invite')

        inviter = User.query.filter(
            User.invite_code == used_invite,
            (User.is_admin == True) | (User.is_creator == True)
        ).first()
        if not inviter:
            return render_template('register.html', error="Неверный инвайт-код или недостаточные права пригласившего.")

        if User.query.filter_by(nickname=data['nickname']).first():
            return render_template('register.html', error="Пользователь с таким никнеймом уже существует.")

        user_uuid = str(uuid.uuid4())
        hashed_password = generate_password_hash(data['password'])
        personal_invite = str(uuid.uuid4())[:8]

        new_user = User(
            uuid=user_uuid,
            nickname=data['nickname'],
            first_name=data.get('first_name'),
            last_name=data.get('last_name'),
            email=data.get('email'),
            telegram=data['telegram'],
            password=hashed_password,
            solved_tasks=0,
            solved_vms=0,
            score=0,
            profile_description=data.get('profile_description', ''),
            invite_code=personal_invite,
            used_invite_code=used_invite,
            is_admin=False,
            is_creator=False
        )
        db.session.add(new_user)
        db.session.commit()
        return redirect(url_for('login'))

    return render_template('register.html')


@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        data = request.form
        user = User.query.filter_by(nickname=data['nickname']).first()
        if user and check_password_hash(user.password, data['password']):
            login_user(user)  # логиним через flask-login
            return redirect(url_for('index'))
        return render_template('login.html', error="Неверный никнейм или пароль.")

    return render_template('login.html')


@app.route('/profile')
@login_required  # требует авторизации
def profile():
    return render_template("profile.html", user=current_user, active_page="profile")


@app.route('/logout', methods=['POST'])
@login_required
def logout():
    logout_user()  # разлогиниваем через flask-login
    return redirect(url_for('login'))


def create_default_user():
    existing = User.query.filter_by(nickname='trager').first()
    if not existing:
        default_user = User(
            uuid=str(uuid.uuid4()),
            nickname='trager',
            first_name=None,
            last_name=None,
            email='tragernout@yandex.ru',
            telegram='@trager',
            password=generate_password_hash('123'),
            solved_tasks=0,
            solved_vms=0,
            score=0,
            profile_description='',
            invite_code='default123',
            used_invite_code='-',
            is_admin=True,
            is_creator=True
        )
        db.session.add(default_user)
        db.session.commit()


@click.command('init-db')
@with_appcontext
def init_db_command():
    db.create_all()
    create_default_user()
    print("✅ База данных и пользователь trager созданы.")


def register_commands(app):
    app.cli.add_command(init_db_command)


register_commands(app)

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
        create_default_user()
    app.run(debug=True)
